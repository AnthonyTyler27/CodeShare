{"id":"../node_modules/engine.io-client/build/esm/transports/polling.js","dependencies":[{"name":"C:\\Users\\Dell\\CodeShare\\package.json","includedInParent":true,"mtime":1686079759432},{"name":"C:\\Users\\Dell\\CodeShare\\node_modules\\engine.io-client\\build\\esm\\package.json","includedInParent":true,"mtime":1685547244006},{"name":"../transport.js","loc":{"line":1,"column":26,"index":26},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\engine.io-client\\build\\esm\\transports\\polling.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\engine.io-client\\build\\esm\\transport.js"},{"name":"../contrib/yeast.js","loc":{"line":2,"column":22,"index":67},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\engine.io-client\\build\\esm\\transports\\polling.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\engine.io-client\\build\\esm\\contrib\\yeast.js"},{"name":"../contrib/parseqs.js","loc":{"line":3,"column":23,"index":113},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\engine.io-client\\build\\esm\\transports\\polling.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\engine.io-client\\build\\esm\\contrib\\parseqs.js"},{"name":"engine.io-parser","loc":{"line":4,"column":45,"index":183},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\engine.io-client\\build\\esm\\transports\\polling.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\engine.io-parser\\build\\esm\\index.js"},{"name":"./xmlhttprequest.js","loc":{"line":5,"column":38,"index":241},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\engine.io-client\\build\\esm\\transports\\polling.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\engine.io-client\\build\\esm\\transports\\xmlhttprequest.browser.js"},{"name":"@socket.io/component-emitter","loc":{"line":6,"column":24,"index":288},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\engine.io-client\\build\\esm\\transports\\polling.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\@socket.io\\component-emitter\\index.mjs"},{"name":"../util.js","loc":{"line":7,"column":44,"index":364},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\engine.io-client\\build\\esm\\transports\\polling.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\engine.io-client\\build\\esm\\util.js"},{"name":"../globalThis.js","loc":{"line":8,"column":45,"index":423},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\engine.io-client\\build\\esm\\transports\\polling.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\engine.io-client\\build\\esm\\globalThis.browser.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Request = exports.Polling = void 0;\n\nvar _transport = require(\"../transport.js\");\n\nvar _yeast = require(\"../contrib/yeast.js\");\n\nvar _parseqs = require(\"../contrib/parseqs.js\");\n\nvar _engine = require(\"engine.io-parser\");\n\nvar _xmlhttprequest = require(\"./xmlhttprequest.js\");\n\nvar _componentEmitter = require(\"@socket.io/component-emitter\");\n\nvar _util = require(\"../util.js\");\n\nvar _globalThis = require(\"../globalThis.js\");\n\nfunction empty() {}\n\nconst hasXHR2 = function () {\n  const xhr = new _xmlhttprequest.XHR({\n    xdomain: false\n  });\n  return null != xhr.responseType;\n}();\n\nclass Polling extends _transport.Transport {\n  /**\n   * XHR Polling constructor.\n   *\n   * @param {Object} opts\n   * @package\n   */\n  constructor(opts) {\n    super(opts);\n    this.polling = false;\n\n    if (typeof location !== \"undefined\") {\n      const isSSL = \"https:\" === location.protocol;\n      let port = location.port; // some user agents have empty `location.port`\n\n      if (!port) {\n        port = isSSL ? \"443\" : \"80\";\n      }\n\n      this.xd = typeof location !== \"undefined\" && opts.hostname !== location.hostname || port !== opts.port;\n      this.xs = opts.secure !== isSSL;\n    }\n    /**\n     * XHR supports binary\n     */\n\n\n    const forceBase64 = opts && opts.forceBase64;\n    this.supportsBinary = hasXHR2 && !forceBase64;\n  }\n\n  get name() {\n    return \"polling\";\n  }\n  /**\n   * Opens the socket (triggers polling). We write a PING message to determine\n   * when the transport is open.\n   *\n   * @protected\n   */\n\n\n  doOpen() {\n    this.poll();\n  }\n  /**\n   * Pauses polling.\n   *\n   * @param {Function} onPause - callback upon buffers are flushed and transport is paused\n   * @package\n   */\n\n\n  pause(onPause) {\n    this.readyState = \"pausing\";\n\n    const pause = () => {\n      this.readyState = \"paused\";\n      onPause();\n    };\n\n    if (this.polling || !this.writable) {\n      let total = 0;\n\n      if (this.polling) {\n        total++;\n        this.once(\"pollComplete\", function () {\n          --total || pause();\n        });\n      }\n\n      if (!this.writable) {\n        total++;\n        this.once(\"drain\", function () {\n          --total || pause();\n        });\n      }\n    } else {\n      pause();\n    }\n  }\n  /**\n   * Starts polling cycle.\n   *\n   * @private\n   */\n\n\n  poll() {\n    this.polling = true;\n    this.doPoll();\n    this.emitReserved(\"poll\");\n  }\n  /**\n   * Overloads onData to detect payloads.\n   *\n   * @protected\n   */\n\n\n  onData(data) {\n    const callback = packet => {\n      // if its the first message we consider the transport open\n      if (\"opening\" === this.readyState && packet.type === \"open\") {\n        this.onOpen();\n      } // if its a close packet, we close the ongoing requests\n\n\n      if (\"close\" === packet.type) {\n        this.onClose({\n          description: \"transport closed by the server\"\n        });\n        return false;\n      } // otherwise bypass onData and handle the message\n\n\n      this.onPacket(packet);\n    }; // decode payload\n\n\n    (0, _engine.decodePayload)(data, this.socket.binaryType).forEach(callback); // if an event did not trigger closing\n\n    if (\"closed\" !== this.readyState) {\n      // if we got data we're not polling\n      this.polling = false;\n      this.emitReserved(\"pollComplete\");\n\n      if (\"open\" === this.readyState) {\n        this.poll();\n      } else {}\n    }\n  }\n  /**\n   * For polling, send a close packet.\n   *\n   * @protected\n   */\n\n\n  doClose() {\n    const close = () => {\n      this.write([{\n        type: \"close\"\n      }]);\n    };\n\n    if (\"open\" === this.readyState) {\n      close();\n    } else {\n      // in case we're trying to close while\n      // handshaking is in progress (GH-164)\n      this.once(\"open\", close);\n    }\n  }\n  /**\n   * Writes a packets payload.\n   *\n   * @param {Array} packets - data packets\n   * @protected\n   */\n\n\n  write(packets) {\n    this.writable = false;\n    (0, _engine.encodePayload)(packets, data => {\n      this.doWrite(data, () => {\n        this.writable = true;\n        this.emitReserved(\"drain\");\n      });\n    });\n  }\n  /**\n   * Generates uri for connection.\n   *\n   * @private\n   */\n\n\n  uri() {\n    let query = this.query || {};\n    const schema = this.opts.secure ? \"https\" : \"http\";\n    let port = \"\"; // cache busting is forced\n\n    if (false !== this.opts.timestampRequests) {\n      query[this.opts.timestampParam] = (0, _yeast.yeast)();\n    }\n\n    if (!this.supportsBinary && !query.sid) {\n      query.b64 = 1;\n    } // avoid port if default for schema\n\n\n    if (this.opts.port && (\"https\" === schema && Number(this.opts.port) !== 443 || \"http\" === schema && Number(this.opts.port) !== 80)) {\n      port = \":\" + this.opts.port;\n    }\n\n    const encodedQuery = (0, _parseqs.encode)(query);\n    const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n    return schema + \"://\" + (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? \"?\" + encodedQuery : \"\");\n  }\n  /**\n   * Creates a request.\n   *\n   * @param {String} method\n   * @private\n   */\n\n\n  request(opts = {}) {\n    Object.assign(opts, {\n      xd: this.xd,\n      xs: this.xs\n    }, this.opts);\n    return new Request(this.uri(), opts);\n  }\n  /**\n   * Sends data.\n   *\n   * @param {String} data to send.\n   * @param {Function} called upon flush.\n   * @private\n   */\n\n\n  doWrite(data, fn) {\n    const req = this.request({\n      method: \"POST\",\n      data: data\n    });\n    req.on(\"success\", fn);\n    req.on(\"error\", (xhrStatus, context) => {\n      this.onError(\"xhr post error\", xhrStatus, context);\n    });\n  }\n  /**\n   * Starts a poll cycle.\n   *\n   * @private\n   */\n\n\n  doPoll() {\n    const req = this.request();\n    req.on(\"data\", this.onData.bind(this));\n    req.on(\"error\", (xhrStatus, context) => {\n      this.onError(\"xhr poll error\", xhrStatus, context);\n    });\n    this.pollXhr = req;\n  }\n\n}\n\nexports.Polling = Polling;\n\nclass Request extends _componentEmitter.Emitter {\n  /**\n   * Request constructor\n   *\n   * @param {Object} options\n   * @package\n   */\n  constructor(uri, opts) {\n    super();\n    (0, _util.installTimerFunctions)(this, opts);\n    this.opts = opts;\n    this.method = opts.method || \"GET\";\n    this.uri = uri;\n    this.async = false !== opts.async;\n    this.data = undefined !== opts.data ? opts.data : null;\n    this.create();\n  }\n  /**\n   * Creates the XHR object and sends the request.\n   *\n   * @private\n   */\n\n\n  create() {\n    const opts = (0, _util.pick)(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n    opts.xdomain = !!this.opts.xd;\n    opts.xscheme = !!this.opts.xs;\n    const xhr = this.xhr = new _xmlhttprequest.XHR(opts);\n\n    try {\n      xhr.open(this.method, this.uri, this.async);\n\n      try {\n        if (this.opts.extraHeaders) {\n          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n\n          for (let i in this.opts.extraHeaders) {\n            if (this.opts.extraHeaders.hasOwnProperty(i)) {\n              xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n            }\n          }\n        }\n      } catch (e) {}\n\n      if (\"POST\" === this.method) {\n        try {\n          xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n        } catch (e) {}\n      }\n\n      try {\n        xhr.setRequestHeader(\"Accept\", \"*/*\");\n      } catch (e) {} // ie6 check\n\n\n      if (\"withCredentials\" in xhr) {\n        xhr.withCredentials = this.opts.withCredentials;\n      }\n\n      if (this.opts.requestTimeout) {\n        xhr.timeout = this.opts.requestTimeout;\n      }\n\n      xhr.onreadystatechange = () => {\n        if (4 !== xhr.readyState) return;\n\n        if (200 === xhr.status || 1223 === xhr.status) {\n          this.onLoad();\n        } else {\n          // make sure the `error` event handler that's user-set\n          // does not throw in the same tick and gets caught here\n          this.setTimeoutFn(() => {\n            this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n          }, 0);\n        }\n      };\n\n      xhr.send(this.data);\n    } catch (e) {\n      // Need to defer since .create() is called directly from the constructor\n      // and thus the 'error' event can only be only bound *after* this exception\n      // occurs.  Therefore, also, we cannot throw here at all.\n      this.setTimeoutFn(() => {\n        this.onError(e);\n      }, 0);\n      return;\n    }\n\n    if (typeof document !== \"undefined\") {\n      this.index = Request.requestsCount++;\n      Request.requests[this.index] = this;\n    }\n  }\n  /**\n   * Called upon error.\n   *\n   * @private\n   */\n\n\n  onError(err) {\n    this.emitReserved(\"error\", err, this.xhr);\n    this.cleanup(true);\n  }\n  /**\n   * Cleans up house.\n   *\n   * @private\n   */\n\n\n  cleanup(fromError) {\n    if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n      return;\n    }\n\n    this.xhr.onreadystatechange = empty;\n\n    if (fromError) {\n      try {\n        this.xhr.abort();\n      } catch (e) {}\n    }\n\n    if (typeof document !== \"undefined\") {\n      delete Request.requests[this.index];\n    }\n\n    this.xhr = null;\n  }\n  /**\n   * Called upon load.\n   *\n   * @private\n   */\n\n\n  onLoad() {\n    const data = this.xhr.responseText;\n\n    if (data !== null) {\n      this.emitReserved(\"data\", data);\n      this.emitReserved(\"success\");\n      this.cleanup();\n    }\n  }\n  /**\n   * Aborts the request.\n   *\n   * @package\n   */\n\n\n  abort() {\n    this.cleanup();\n  }\n\n}\n\nexports.Request = Request;\nRequest.requestsCount = 0;\nRequest.requests = {};\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\n\nif (typeof document !== \"undefined\") {\n  // @ts-ignore\n  if (typeof attachEvent === \"function\") {\n    // @ts-ignore\n    attachEvent(\"onunload\", unloadHandler);\n  } else if (typeof addEventListener === \"function\") {\n    const terminationEvent = \"onpagehide\" in _globalThis.globalThisShim ? \"pagehide\" : \"unload\";\n    addEventListener(terminationEvent, unloadHandler, false);\n  }\n}\n\nfunction unloadHandler() {\n  for (let i in Request.requests) {\n    if (Request.requests.hasOwnProperty(i)) {\n      Request.requests[i].abort();\n    }\n  }\n}"},"sourceMaps":null,"error":null,"hash":"4921130f6e32cd59dac58e1d50613492","cacheData":{"env":{}}}