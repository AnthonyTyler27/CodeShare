{"id":"../node_modules/@mui/base/useList/useListItem.js","dependencies":[{"name":"C:\\Users\\Dell\\CodeShare\\package.json","includedInParent":true,"mtime":1686079759432},{"name":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\package.json","includedInParent":true,"mtime":1685847519020},{"name":"@babel/runtime/helpers/esm/extends","loc":{"line":1,"column":21,"index":21},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useListItem.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\@babel\\runtime\\helpers\\esm\\extends.js"},{"name":"react","loc":{"line":2,"column":23,"index":82},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useListItem.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\react\\index.js"},{"name":"@mui/utils","loc":{"line":3,"column":99,"index":190},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useListItem.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\utils\\esm\\index.js"},{"name":"../utils/useForcedRerendering","loc":{"line":4,"column":33,"index":237},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useListItem.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\utils\\useForcedRerendering.js"},{"name":"./listActions.types","loc":{"line":5,"column":32,"index":302},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useListItem.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\listActions.types.js"},{"name":"./ListContext","loc":{"line":6,"column":28,"index":353},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useListItem.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\ListContext.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useListItem;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/esm/extends\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _utils = require(\"@mui/utils\");\n\nvar _useForcedRerendering = _interopRequireDefault(require(\"../utils/useForcedRerendering\"));\n\nvar _listActions = require(\"./listActions.types\");\n\nvar _ListContext = require(\"./ListContext\");\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Contains the logic for an item of a list-like component (e.g. Select, Menu, etc.).\n * It provides information about the item's state (selected, highlighted) and\n * handles the item's mouse events.\n *\n * @template ItemValue The type of the item's value. This should be consistent with the type of useList's `items` parameter.\n * @ignore - internal hook.\n */\nfunction useListItem(parameters) {\n  const {\n    handlePointerOverEvents = false,\n    item,\n    rootRef: externalRef\n  } = parameters;\n  const itemRef = React.useRef(null);\n  const handleRef = (0, _utils.unstable_useForkRef)(itemRef, externalRef);\n  const listContext = React.useContext(_ListContext.ListContext);\n\n  if (!listContext) {\n    throw new Error('useListItem must be used within a ListProvider');\n  }\n\n  const {\n    dispatch,\n    getItemState,\n    registerHighlightChangeHandler,\n    registerSelectionChangeHandler\n  } = listContext;\n  const {\n    highlighted,\n    selected,\n    focusable\n  } = getItemState(item);\n  const rerender = (0, _useForcedRerendering.default)();\n  (0, _utils.unstable_useEnhancedEffect)(() => {\n    function updateHighlightedState(highlightedItem) {\n      if (highlightedItem === item && !highlighted) {\n        rerender();\n      } else if (highlightedItem !== item && highlighted) {\n        rerender();\n      }\n    }\n\n    return registerHighlightChangeHandler(updateHighlightedState);\n  });\n  (0, _utils.unstable_useEnhancedEffect)(() => {\n    function updateSelectedState(selectedItems) {\n      if (!selected) {\n        if (selectedItems.includes(item)) {\n          rerender();\n        }\n      } else if (!selectedItems.includes(item)) {\n        rerender();\n      }\n    }\n\n    return registerSelectionChangeHandler(updateSelectedState);\n  }, [registerSelectionChangeHandler, rerender, selected, item]);\n  const createHandleClick = React.useCallback(other => event => {\n    var _other$onClick;\n\n    (_other$onClick = other.onClick) == null ? void 0 : _other$onClick.call(other, event);\n\n    if (event.defaultPrevented) {\n      return;\n    }\n\n    dispatch({\n      type: _listActions.ListActionTypes.itemClick,\n      item,\n      event\n    });\n  }, [dispatch, item]);\n  const createHandlePointerOver = React.useCallback(other => event => {\n    var _other$onMouseOver;\n\n    (_other$onMouseOver = other.onMouseOver) == null ? void 0 : _other$onMouseOver.call(other, event);\n\n    if (event.defaultPrevented) {\n      return;\n    }\n\n    dispatch({\n      type: _listActions.ListActionTypes.itemHover,\n      item,\n      event\n    });\n  }, [dispatch, item]);\n  let tabIndex;\n\n  if (focusable) {\n    tabIndex = highlighted ? 0 : -1;\n  }\n\n  const getRootProps = (otherHandlers = {}) => (0, _extends2.default)({}, otherHandlers, {\n    onClick: createHandleClick(otherHandlers),\n    onPointerOver: handlePointerOverEvents ? createHandlePointerOver(otherHandlers) : undefined,\n    ref: handleRef,\n    tabIndex\n  });\n\n  return {\n    getRootProps,\n    highlighted,\n    rootRef: handleRef,\n    selected\n  };\n}"},"sourceMaps":null,"error":null,"hash":"49744bd00b2c6b1b78ec98f9440c1d56","cacheData":{"env":{}}}