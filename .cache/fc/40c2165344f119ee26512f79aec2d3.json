{"id":"../node_modules/@mui/base/useList/useList.js","dependencies":[{"name":"C:\\Users\\Dell\\CodeShare\\package.json","includedInParent":true,"mtime":1686079759432},{"name":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\package.json","includedInParent":true,"mtime":1685847519020},{"name":"@babel/runtime/helpers/esm/extends","loc":{"line":1,"column":21,"index":21},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useList.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\@babel\\runtime\\helpers\\esm\\extends.js"},{"name":"react","loc":{"line":2,"column":23,"index":82},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useList.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\react\\index.js"},{"name":"@mui/utils","loc":{"line":3,"column":50,"index":141},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useList.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\utils\\esm\\index.js"},{"name":"./listActions.types","loc":{"line":4,"column":32,"index":187},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useList.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\listActions.types.js"},{"name":"./listReducer","loc":{"line":5,"column":27,"index":237},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useList.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\listReducer.js"},{"name":"./useListChangeNotifiers","loc":{"line":6,"column":35,"index":289},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useList.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useListChangeNotifiers.js"},{"name":"../utils/useControllableReducer","loc":{"line":7,"column":35,"index":352},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useList.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\utils\\useControllableReducer.js"},{"name":"../utils/areArraysEqual","loc":{"line":8,"column":27,"index":414},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useList.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\utils\\areArraysEqual.js"},{"name":"../utils/useLatest","loc":{"line":9,"column":22,"index":463},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useList.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\utils\\useLatest.js"},{"name":"../utils/useTextNavigation","loc":{"line":10,"column":30,"index":515},"parent":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\useList\\useList.js","resolved":"C:\\Users\\Dell\\CodeShare\\node_modules\\@mui\\base\\utils\\useTextNavigation.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/esm/extends\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _utils = require(\"@mui/utils\");\n\nvar _listActions = require(\"./listActions.types\");\n\nvar _listReducer = _interopRequireDefault(require(\"./listReducer\"));\n\nvar _useListChangeNotifiers = _interopRequireDefault(require(\"./useListChangeNotifiers\"));\n\nvar _useControllableReducer = _interopRequireDefault(require(\"../utils/useControllableReducer\"));\n\nvar _areArraysEqual = _interopRequireDefault(require(\"../utils/areArraysEqual\"));\n\nvar _useLatest = _interopRequireDefault(require(\"../utils/useLatest\"));\n\nvar _useTextNavigation = _interopRequireDefault(require(\"../utils/useTextNavigation\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst EMPTY_OBJECT = {};\n\nconst NOOP = () => {};\n\nconst defaultItemComparer = (optionA, optionB) => optionA === optionB;\n\nconst defaultIsItemDisabled = () => false;\n\nconst defaultItemStringifier = item => typeof item === 'string' ? item : String(item);\n\nconst defaultGetInitialState = () => ({\n  highlightedValue: null,\n  selectedValues: []\n});\n/**\n * The useList is a lower-level utility that is used to build list-like components.\n * It's used to manage the state of the list and its items.\n *\n * Supports highlighting a single item and selecting an arbitrary number of items.\n *\n * The state of the list is managed by a controllable reducer - that is a reducer that can have its state\n * controlled from outside.\n *\n * By default, the state consists of `selectedValues` and `highlightedValue` but can be extended by the caller of the hook.\n * Also the actions that can be dispatched and the reducer function can be defined externally.\n *\n * @template ItemValue The type of the item values.\n * @template State The type of the list state. This should be a subtype of `ListState<ItemValue>`.\n * @template CustomAction The type of the actions that can be dispatched (besides the standard ListAction).\n * @template CustomActionContext The shape of additional properties that will be added to actions when dispatched.\n *\n * @ignore - internal hook.\n */\n\n\nfunction useList(params) {\n  const {\n    controlledProps = EMPTY_OBJECT,\n    disabledItemsFocusable = false,\n    disableListWrap = false,\n    focusManagement = 'activeDescendant',\n    getInitialState = defaultGetInitialState,\n    getItemDomElement,\n    getItemId,\n    isItemDisabled = defaultIsItemDisabled,\n    rootRef: externalListRef,\n    onStateChange = NOOP,\n    items,\n    itemComparer = defaultItemComparer,\n    getItemAsString = defaultItemStringifier,\n    onChange,\n    onHighlightChange,\n    orientation = 'vertical',\n    pageSize = 5,\n    reducerActionContext = EMPTY_OBJECT,\n    selectionMode = 'single',\n    stateReducer: externalReducer\n  } = params;\n\n  if (\"development\" !== 'production') {\n    if (focusManagement === 'DOM' && getItemDomElement == null) {\n      throw new Error('useList: The `getItemDomElement` prop is required when using the `DOM` focus management.');\n    }\n\n    if (focusManagement === 'activeDescendant' && getItemId == null) {\n      throw new Error('useList: The `getItemId` prop is required when using the `activeDescendant` focus management.');\n    }\n  }\n\n  const listRef = React.useRef(null);\n  const handleRef = (0, _utils.unstable_useForkRef)(externalListRef, listRef);\n  const handleHighlightChange = React.useCallback((event, value, reason) => {\n    onHighlightChange == null ? void 0 : onHighlightChange(event, value, reason);\n\n    if (focusManagement === 'DOM' && value != null && (reason === _listActions.ListActionTypes.itemClick || reason === _listActions.ListActionTypes.keyDown || reason === _listActions.ListActionTypes.textNavigation)) {\n      var _getItemDomElement;\n\n      getItemDomElement == null ? void 0 : (_getItemDomElement = getItemDomElement(value)) == null ? void 0 : _getItemDomElement.focus();\n    }\n  }, [getItemDomElement, onHighlightChange, focusManagement]);\n  const stateComparers = React.useMemo(() => ({\n    highlightedValue: itemComparer,\n    selectedValues: (valuesArray1, valuesArray2) => (0, _areArraysEqual.default)(valuesArray1, valuesArray2, itemComparer)\n  }), [itemComparer]); // This gets called whenever a reducer changes the state.\n\n  const handleStateChange = React.useCallback((event, field, value, reason, state) => {\n    onStateChange == null ? void 0 : onStateChange(event, field, value, reason, state);\n\n    switch (field) {\n      case 'highlightedValue':\n        handleHighlightChange(event, value, reason);\n        break;\n\n      case 'selectedValues':\n        onChange == null ? void 0 : onChange(event, value, reason);\n        break;\n\n      default:\n        break;\n    }\n  }, [handleHighlightChange, onChange, onStateChange]); // The following object is added to each action when it's dispatched.\n  // It's accessible in the reducer via the `action.context` field.\n\n  const listActionContext = React.useMemo(() => {\n    return {\n      disabledItemsFocusable,\n      disableListWrap,\n      focusManagement,\n      isItemDisabled,\n      itemComparer,\n      items,\n      getItemAsString,\n      onHighlightChange: handleHighlightChange,\n      orientation,\n      pageSize,\n      selectionMode,\n      stateComparers\n    };\n  }, [disabledItemsFocusable, disableListWrap, focusManagement, isItemDisabled, itemComparer, items, getItemAsString, handleHighlightChange, orientation, pageSize, selectionMode, stateComparers]);\n  const initialState = getInitialState();\n  const reducer = externalReducer != null ? externalReducer : _listReducer.default;\n  const actionContext = React.useMemo(() => (0, _extends2.default)({}, reducerActionContext, listActionContext), [reducerActionContext, listActionContext]);\n  const [state, dispatch] = (0, _useControllableReducer.default)({\n    reducer,\n    actionContext,\n    initialState: initialState,\n    controlledProps,\n    stateComparers,\n    onStateChange: handleStateChange\n  });\n  const {\n    highlightedValue,\n    selectedValues\n  } = state;\n  const handleTextNavigation = (0, _useTextNavigation.default)((searchString, event) => dispatch({\n    type: _listActions.ListActionTypes.textNavigation,\n    event,\n    searchString\n  })); // introducing refs to avoid recreating the getItemState function on each change.\n\n  const latestSelectedValues = (0, _useLatest.default)(selectedValues);\n  const latestHighlightedValue = (0, _useLatest.default)(highlightedValue);\n  const previousItems = React.useRef([]);\n  React.useEffect(() => {\n    // Whenever the `items` object changes, we need to determine if the actual items changed.\n    // If they did, we need to dispatch an `itemsChange` action, so the selected/highlighted state is updated.\n    if ((0, _areArraysEqual.default)(previousItems.current, items, itemComparer)) {\n      return;\n    }\n\n    dispatch({\n      type: _listActions.ListActionTypes.itemsChange,\n      event: null,\n      items,\n      previousItems: previousItems.current\n    });\n    previousItems.current = items;\n  }, [items, itemComparer, dispatch]); // Subitems are notified of changes to the highlighted and selected values.\n  // This is not done via context because we don't want to trigger a re-render of all the subitems each time any of them changes state.\n  // Instead, we use a custom message bus to publish messages about changes.\n  // On the child component, we use a custom hook to subscribe to these messages and re-render only when the value they care about changes.\n\n  const {\n    notifySelectionChanged,\n    notifyHighlightChanged,\n    registerHighlightChangeHandler,\n    registerSelectionChangeHandler\n  } = (0, _useListChangeNotifiers.default)();\n  React.useEffect(() => {\n    notifySelectionChanged(selectedValues);\n  }, [selectedValues, notifySelectionChanged]);\n  React.useEffect(() => {\n    notifyHighlightChanged(highlightedValue);\n  }, [highlightedValue, notifyHighlightChanged]);\n\n  const createHandleKeyDown = other => event => {\n    var _other$onKeyDown;\n\n    (_other$onKeyDown = other.onKeyDown) == null ? void 0 : _other$onKeyDown.call(other, event);\n\n    if (event.defaultMuiPrevented) {\n      return;\n    }\n\n    const keysToPreventDefault = ['Home', 'End', 'PageUp', 'PageDown'];\n\n    if (orientation === 'vertical') {\n      keysToPreventDefault.push('ArrowUp', 'ArrowDown');\n    } else {\n      keysToPreventDefault.push('ArrowLeft', 'ArrowRight');\n    }\n\n    if (focusManagement === 'activeDescendant') {\n      // When the child element is focused using the activeDescendant attribute,\n      // the list handles keyboard events on its behalf.\n      // We have to `preventDefault()` is this case to prevent the browser from\n      // scrolling the view when space is pressed or submitting forms when enter is pressed.\n      keysToPreventDefault.push(' ', 'Enter');\n    }\n\n    if (keysToPreventDefault.includes(event.key)) {\n      event.preventDefault();\n    }\n\n    dispatch({\n      type: _listActions.ListActionTypes.keyDown,\n      key: event.key,\n      event\n    });\n    handleTextNavigation(event);\n  };\n\n  const createHandleBlur = other => event => {\n    var _other$onBlur, _listRef$current;\n\n    (_other$onBlur = other.onBlur) == null ? void 0 : _other$onBlur.call(other, event);\n\n    if (event.defaultMuiPrevented) {\n      return;\n    }\n\n    if ((_listRef$current = listRef.current) != null && _listRef$current.contains(event.relatedTarget)) {\n      // focus remains within the list\n      return;\n    }\n\n    dispatch({\n      type: _listActions.ListActionTypes.blur,\n      event\n    });\n  };\n\n  const getRootProps = (otherHandlers = {}) => {\n    return (0, _extends2.default)({}, otherHandlers, {\n      'aria-activedescendant': focusManagement === 'activeDescendant' && highlightedValue != null ? getItemId(highlightedValue) : undefined,\n      onBlur: createHandleBlur(otherHandlers),\n      onKeyDown: createHandleKeyDown(otherHandlers),\n      tabIndex: focusManagement === 'DOM' ? -1 : 0,\n      ref: handleRef\n    });\n  };\n\n  const getItemState = React.useCallback(item => {\n    var _latestSelectedValues;\n\n    const index = items.findIndex(i => itemComparer(i, item));\n    const selected = ((_latestSelectedValues = latestSelectedValues.current) != null ? _latestSelectedValues : []).some(value => value != null && itemComparer(item, value));\n    const disabled = isItemDisabled(item, index);\n    const highlighted = latestHighlightedValue.current != null && itemComparer(item, latestHighlightedValue.current);\n    const focusable = focusManagement === 'DOM';\n    return {\n      disabled,\n      focusable,\n      highlighted,\n      index,\n      selected\n    };\n  }, [items, isItemDisabled, itemComparer, latestSelectedValues, latestHighlightedValue, focusManagement]);\n  const contextValue = React.useMemo(() => ({\n    dispatch,\n    getItemState,\n    registerHighlightChangeHandler,\n    registerSelectionChangeHandler\n  }), [dispatch, getItemState, registerHighlightChangeHandler, registerSelectionChangeHandler]);\n  React.useDebugValue({\n    state\n  });\n  return {\n    contextValue,\n    dispatch,\n    getRootProps,\n    rootRef: handleRef,\n    state\n  };\n}\n\nvar _default = useList;\nexports.default = _default;"},"sourceMaps":null,"error":null,"hash":"d04fc26e7481f08d5f36633b14dae98b","cacheData":{"env":{"NODE_ENV":"development"}}}